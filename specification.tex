\chapter{Specification}
\label{chap:specification}

\section*{}

This project is structured in a modular way; this chapter enumerates and
describes each one of the modules, defining what is required and produced in
each step. Three main modules were designed, and the general workflow is
described in section~\ref{section:workflow}, with the main modules being
explained in the following sections.

Then, all the data interchange formats used to communicate between modules are
formally specified.




\section{Workflow}
\label{section:workflow}

To understand the following architecture and underlying information flow, one
must have in mind that this project has two major components. First, several
optimization algorithms must be compared, using both real and fabricated
scenarios. In second place, the system must be ready to be integrated with the
fill status monitoring solution being developed at \fhp{}.

First, the optimization module itself must receive a dataset describing the
collection scenario, which should contain:

\begin{itemize}
  \item city topology
  \item waste containers' location
  \item vehicle starting point
  \item minimum and maximum number of vehicles
\end{itemize}

With this information, it shall produce a single file describing one route per
used vehicle. This file can then be fed to the evaluation module, which
determines the solution's performance, according to several metrics, described
later on in section~\ref{section:metrics}. This performance evaluation
mechanism will be used mainly during the comparison phase of this project,
while the optimization module will be used in both phases.

Dataset information is gathered from several different places: maps can be
randomly generated or retrieved from GIS sources, as described in
section~\ref{section:maps}; containers' fill status can also be stochastically
generated or obtained from the monitoring system's database. These data are
then normalized and merged to form a single dataset file. The full information
flow can be seen in figure~\ref{fig:architecture}.

\begin{figure}[th]
  \begin{center}
    \leavevmode
    \input{figures/architecture}
    \caption{Project architecture}
    \label{fig:architecture}
  \end{center}
\end{figure}

Note that there is the need to manage independent city and containers' status
files before creating a normalized dataset. This happens because the random
container generator depends on the city file to create valid scenarios.





\newpage
\section{Data formats}
\label{section:formats}

As seen in figure~\ref{fig:architecture}, there are five different files that
carry information from one module to the next. To ease implementation, all five
formats were specified using the same notation.

Examples of common data interchange formats are XML (Extensible Markup
Language) and JSON (JavaScript Object Notation). Advantages of such standards
are, for example, the ready availability of several parsers for a great number
of languages\citep{site:json}\cite{site:xml}, their openness and simplicity.

Between these two notations, it was decided to use the JSON format. It was
chosen because it is simpler than XML and because it was specifically designed
to be a lightweight computer data interchange format, whereas XML was designed
to be a document interchange format\citep{site:json}.

JSON is based on two universal data structures: ordered lists and keyed lists
(from here on out called \textit{objects}).  The latter structure is also known
in various programming languages as a \textit{dictionary}, \textit{hash table},
\textit{associative array} and others. There are also primitive types
available, such as strings, numbers and three constants: \texttt{true},
\texttt{false} and \texttt{null}.

While objects' keys must be strings, their values can be of any type, either
primitive or not. The same is true for ordered lists' elements. Further details
regarding JSON syntax can be found in the RFC 4627\citep{site:rfc-json}.

Following sections will describe each one of the five formats present in this
system's architecture[TODO: get a better syntax format thing].






\subsection{City map format}
\label{section:map-format}

A city map file is composed of a single JSON object
(\textbf{\texttt{city\_map}}). This contains two pairs of key/values; one of
them, whose key is \texttt{name}, has a string as its value and represents the
city map name, being used as human-readable metadata. Its second pair has the
key \texttt{graph} and its value represents the city topology, described as an
adjacency list --- a data structure commonly used to describe graphs.  This
adjacency list is defined as an ordered list, where each element represents a
vertex.

Each vertex is represented by a JSON object, containing a key/value pair for
its latitude (\texttt{lat}) and its longitude (\texttt{lon}), with both values
being represented as JSON numbers. A third key/value pair is present; its key
is \texttt{roads}, and its value defines the vertex's neighbors. This neighbor
list is encoded as a JSON ordered list, with each element identifying the
neighbor by its index in the main adjacency list.

A sample graph and its corresponding \textbf{\texttt{city\_map}} object can be
seen in figure~\ref{fig:city-map-example}.


\begin{figure}[th]
  \begin{center}
    \leavevmode
    \input{figures/city-map-example}
    \caption{An example city topology map and its JSON equivalent.}
    \label{fig:city-map-example}
  \end{center}
\end{figure}




\newpage
\subsection{Containers status format}
\label{section:container-format}

The containers' fill status file contains, for each container, its location ---
latitude and longitude --- and the current amount of waste stored in it. This
is represented by a JSON ordered list, with an element per container. Each
container element is a JSON object and contains three key/value pairs: one for
its latitude (\texttt{lat}), one for its longitude (\texttt{lon}) and one for
its current fill (\texttt{fill}). An example JSON object is available in
figure~\ref{fig:containers-example}.

\begin{figure}[th]
  \begin{center}
    \leavevmode
      \begin{minipage}{9cm}
    \begin{verbatim}
[
 {"lat": 0.0, "lon": 0.0, "fill": 43.01},
 {"lat": 4.1, "lon": -0.9, "fill": 18.47}
]
    \end{verbatim}
    \end{minipage}
    \caption{An example containers' fill status JSON file.}
    \label{fig:containers-example}
  \end{center}
\end{figure}





\subsection{Dataset format}
\label{section:dataset-format}

After obtaining both the city map file and the containers' status file, they
must be merged together to form a single dataset file. This action is performed
by the \textit{normalizer} module, shown previously in figure~\ref{fig:architecture}.

This format contains both features regarding the city topology and the
containers' fill status. Each container geographical position is matched
against the graph's vertices and its fill status information is added to the
closest vertex.

The dataset schema is similar to the one presented in
section~\ref{section:map-format}, with a few changes. First, for each vertex in
which a waste container is present, there is an additional key/value pair
representing its fill status, as defined in
section~\ref{section:container-format}. Second, two new key/value pairs must be
added to the main JSON object; one regarding the maximum number of trucks to
use (\texttt{max\_trucks}) and one regarding the starting/ending node
(\texttt{depot}). These two extra parameters must be defined when running the normalization process,
and are not present in any of the previous data file formats.

Taking the examples presented in the two previous sections, they could be
normalized into the dataset file present in figure~\ref{fig:dataset-example}.

\begin{figure}[th]
  \begin{center}
    \leavevmode
      \begin{minipage}{12cm}
    \begin{verbatim}
{"name": "Sample city",
 "max_trucks": 3,
 "depot": 1,
 "graph": [
  {"lat": 0, "lon": 0, "roads": [4], "fill": 43.01},
  {"lat": 2, "lon": -1, "roads": [0,3]},
  {"lat": 4, "lon": 1, "roads": [3,4]},
  {"lat": 4, "lon": -1, "roads": [1,2,4], 18.47},
  {"lat": 2, "lon": 1, "roads": [1,2,3]}
]}
    \end{verbatim}
    \end{minipage}
    \caption{Complete dataset example object, constructed from previous examples.}
    \label{fig:dataset-example}
  \end{center}
\end{figure}





\subsection{Routes format}
\label{section:routes-format}

The optimization module must process a single dataset file and determine a
near-optimal set of routes --- one for each vehicle. Each vehicle route can be
defined as an ordered list of references to the city vertices.

When dealing with commercial scenarios, each vertex there should be paired with
a boolean indicator that tells if the vehicle must empty the waste container
present at that location. In the Rollon-Rolloff scenario, this additional
flag indicates if the vehicle should load/unload a container at that location.

The set of routes can be defined as a JSON ordered list, with each element
defining a single route. Each route can also be represented by an ordered list
of vertex references. These are themselves defined as ordered lists of two
values; the first value represents the vertex index, while the second is a
boolean value, determining if the vehicle should or should not act on that
specific location.

Figure~\ref{fig:routes-example-rr} shows an example of a two-vehicle routes
file, in the Rollon-Rolloff scenario, after applying an optimization technique
to the previously shown dataset. Each vehicle starts by loading an empty
container at vertex 1, moves to a location with a full container and switches
the empty with the full one. Then, both vehicles proceed back to the depot
location, where they deposit the picked up containers.

\begin{figure}[th]
  \begin{center}
    \leavevmode
      \begin{minipage}{14cm}
    \begin{verbatim}
[
 [[1, true], [4, true], [4, true], [0, false], [1, true]],
 [[1, true], [3, true], [3, true], [1, true]]
]
    \end{verbatim}
    \end{minipage}
    \caption{Rollon-Rolloff set of routes example, representing two vehicles.}
    \label{fig:routes-example-rr}
  \end{center}
\end{figure}




\newpage
\subsection{Statistics format}
\label{section:statistics-format}

The fifth data format regards the statistics obtained when evaluating the
routes obtained by a given optimization module. These metrics are calculated
based on the routes and the dataset files. The output object is represented as
a JSON object, where each key/value pair represents a different metric. This
representation is left open, as metrics may be added and/or removed during the
algorithm comparison phase.



